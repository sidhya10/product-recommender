<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Product Recommender App with AI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #root {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #root {
      display: flex;
      flex-direction: column;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
  // Import ProductRecommender component
  const ProductRecommender = (() => {
    const { useState, useRef, useEffect } = React;

    return () => {
      // Basic state
      const [messages, setMessages] = useState([
        {
          role: 'assistant',
          content: 'Hi there! I can help you find the perfect tech product based on your needs. What are you looking for today? (For example: laptop, smartphone, headphones, etc.)'
        }
      ]);
      const [inputText, setInputText] = useState('');
      const [isTyping, setIsTyping] = useState(false);
      const [productContext, setProductContext] = useState({
        category: null,
        budget: null,
        preferences: [],
        stage: 'initial'
      });

      // Advanced state for more dynamic behavior
      const [askedQuestions, setAskedQuestions] = useState({
        budget: false,
        features: false
      });
      const [searchHistory, setSearchHistory] = useState([]);
      const [userPreferenceProfile, setUserPreferenceProfile] = useState({
        priceConsciousness: 'medium', // low, medium, high
        preferredBrands: [],
        valuedFeatures: [],
        lastSearched: null
      });

      const messagesEndRef = useRef(null);

      // OpenAI API configuration
      const OPENAI_API_KEY = "";
      const API_BASE_URL = "https://api.openai.com/v1";

      // Sample product database
      const products = [
        {
          id: 1,
          category: 'laptop',
          name: 'ProBook X5',
          price: 1299,
          features: ['13" Retina display', '16GB RAM', '512GB SSD', 'All-day battery life', 'Ultra-lightweight'],
          idealFor: ['professionals', 'travelers', 'students', 'designers'],
          rating: 4.8,
          image: '/api/placeholder/300/200'
        },
        {
          id: 2,
          category: 'laptop',
          name: 'TechMaster 7000',
          price: 999,
          features: ['15.6" FHD display', '8GB RAM', '256GB SSD', 'Gaming graphics card', 'Customizable keyboard'],
          idealFor: ['gamers', 'students', 'casual users'],
          rating: 4.3,
          image: '/api/placeholder/300/200'
        },
        {
          id: 3,
          category: 'laptop',
          name: 'UltraSlim Pro',
          price: 1499,
          features: ['14" 4K OLED display', '32GB RAM', '1TB SSD', 'Precision touchpad', 'Professional graphics'],
          idealFor: ['designers', 'video editors', 'professionals'],
          rating: 4.9,
          image: '/api/placeholder/300/200'
        },
        {
          id: 4,
          category: 'smartphone',
          name: 'Galaxy Ultra',
          price: 899,
          features: ['6.7" Super AMOLED', '8GB RAM', '256GB Storage', 'Triple camera system', 'All-day battery'],
          idealFor: ['photographers', 'professionals', 'tech enthusiasts'],
          rating: 4.7,
          image: '/api/placeholder/200/300'
        },
        {
          id: 5,
          category: 'smartphone',
          name: 'Pixel Pro',
          price: 799,
          features: ['6.4" OLED display', 'Best-in-class camera', 'Clean OS experience', 'Fast charging', 'Long-term updates'],
          idealFor: ['photographers', 'Android purists', 'casual users'],
          rating: 4.6,
          image: '/api/placeholder/200/300'
        },
        {
          id: 6,
          category: 'smartphone',
          name: 'Budget King 5',
          price: 349,
          features: ['6.5" LCD display', 'Decent camera', '128GB Storage', 'Headphone jack', 'Expandable storage'],
          idealFor: ['budget-conscious users', 'students', 'casual users'],
          rating: 4.2,
          image: '/api/placeholder/200/300'
        },
        {
          id: 7,
          category: 'headphones',
          name: 'SoundMaster Pro',
          price: 299,
          features: ['Active noise cancellation', 'Hi-Res audio', '30-hour battery life', 'Premium build quality', 'Spatial audio'],
          idealFor: ['audiophiles', 'travelers', 'professionals'],
          rating: 4.8,
          image: '/api/placeholder/300/200'
        },
        {
          id: 8,
          category: 'headphones',
          name: 'BassBoost 700',
          price: 179,
          features: ['Enhanced bass response', 'Comfortable fit', '25-hour battery life', 'Built-in mic', 'Foldable design'],
          idealFor: ['bass lovers', 'commuters', 'casual listeners'],
          rating: 4.4,
          image: '/api/placeholder/300/200'
        },
        {
          id: 9,
          category: 'headphones',
          name: 'EcoSound Mini',
          price: 89,
          features: ['Compact design', 'Good sound quality', '20-hour battery', 'Water resistant', 'Built-in controls'],
          idealFor: ['budget-conscious users', 'gym-goers', 'casual listeners'],
          rating: 4.1,
          image: '/api/placeholder/300/200'
        }
      ];

      // Auto-scroll to bottom of messages
      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      // Enhanced detection functions
      const detectCategory = (message) => {
        const lowercaseMessage = message.toLowerCase().trim();

        // Immediate return for single-word category mentions
        if (lowercaseMessage === 'laptop' ||
                lowercaseMessage === 'laptops' ||
                lowercaseMessage === 'computer' ||
                lowercaseMessage === 'computers') {
          return 'laptop';
        }

        if (lowercaseMessage === 'phone' ||
                lowercaseMessage === 'phones' ||
                lowercaseMessage === 'smartphone' ||
                lowercaseMessage === 'smartphones' ||
                lowercaseMessage === 'mobile' ||
                lowercaseMessage === 'mobiles') {
          return 'smartphone';
        }

        if (lowercaseMessage === 'headphone' ||
                lowercaseMessage === 'headphones' ||
                lowercaseMessage === 'earphone' ||
                lowercaseMessage === 'earphones' ||
                lowercaseMessage === 'earbuds' ||
                lowercaseMessage === 'earbud' ||
                lowercaseMessage === 'headset' ||
                lowercaseMessage === 'headsets') {
          return 'headphones';
        }

        // Continue with the rest of the original detection logic if no exact match
        // Direct category detection
        if (lowercaseMessage.includes('laptop') ||
                lowercaseMessage.includes('notebook') ||
                lowercaseMessage.includes('computer') ||
                lowercaseMessage.includes('pc') ||
                lowercaseMessage.includes('macbook')) {
          return 'laptop';
        }

        if (lowercaseMessage.includes('phone') ||
                lowercaseMessage.includes('smartphone') ||
                lowercaseMessage.includes('mobile') ||
                lowercaseMessage.includes('iphone') ||
                lowercaseMessage.includes('android') ||
                lowercaseMessage.includes('cell phone')) {
          return 'smartphone';
        }

        if (lowercaseMessage.includes('headphone') ||
                lowercaseMessage.includes('earphone') ||
                lowercaseMessage.includes('earbuds') ||
                lowercaseMessage.includes('headset') ||
                lowercaseMessage.includes('airpods')) {
          return 'headphones';
        }

        // Indirect category detection through brand names
        const laptopBrands = ['dell', 'hp', 'lenovo', 'asus', 'acer', 'microsoft surface', 'macbook'];
        const phoneBrands = ['iphone', 'samsung', 'google pixel', 'oneplus', 'xiaomi', 'huawei'];
        const headphoneBrands = ['bose', 'sony', 'sennheiser', 'beats', 'airpods', 'jabra'];

        for (const brand of laptopBrands) {
          if (lowercaseMessage.includes(brand)) {
            return 'laptop';
          }
        }

        for (const brand of phoneBrands) {
          if (lowercaseMessage.includes(brand)) {
            return 'smartphone';
          }
        }

        for (const brand of headphoneBrands) {
          if (lowercaseMessage.includes(brand)) {
            return 'headphones';
          }
        }

        // Activity-based detection
        if (lowercaseMessage.includes('coding') ||
                lowercaseMessage.includes('programming') ||
                lowercaseMessage.includes('work') ||
                lowercaseMessage.includes('office') ||
                lowercaseMessage.includes('study') ||
                lowercaseMessage.includes('school')) {
          return 'laptop';
        }

        if (lowercaseMessage.includes('call') ||
                lowercaseMessage.includes('text') ||
                lowercaseMessage.includes('camera') ||
                lowercaseMessage.includes('photos') ||
                lowercaseMessage.includes('social media')) {
          return 'smartphone';
        }

        if (lowercaseMessage.includes('music') ||
                lowercaseMessage.includes('audio') ||
                lowercaseMessage.includes('sound') ||
                lowercaseMessage.includes('listening') ||
                lowercaseMessage.includes('noise cancelling') ||
                lowercaseMessage.includes('wireless audio')) {
          return 'headphones';
        }

        return null;
      };

      // Enhanced budget extraction
      const extractBudget = (message) => {
        const lowercaseMessage = message.toLowerCase();

        // Handle numeric ranges with or without currency symbols
        const rangeRegex = /\$?(\d+(?:[,.]\d+)?)\s*(?:-|to)\s*\$?(\d+(?:[,.]\d+)?)/i;
        const rangeSeparators = ['-', 'to', 'and', 'between', 'from'];

        // Check for explicit ranges
        const rangeMatch = lowercaseMessage.match(rangeRegex);
        if (rangeMatch) {
          const min = parseFloat(rangeMatch[1].replace(/,/g, ''));
          const max = parseFloat(rangeMatch[2].replace(/,/g, ''));
          return { min, max };
        }

        // Common range expressions
        for (const sep of rangeSeparators) {
          if (lowercaseMessage.includes(sep)) {
            const parts = lowercaseMessage.split(sep);
            const numbers = [];

            // Extract numbers from each part
            for (const part of parts) {
              const numMatch = part.match(/\$?(\d+(?:[,.]\d+)?)/);
              if (numMatch) {
                numbers.push(parseFloat(numMatch[1].replace(/,/g, '')));
              }
            }

            // If we found two numbers, use them as min and max
            if (numbers.length >= 2) {
              return { min: Math.min(...numbers), max: Math.max(...numbers) };
            }
          }
        }

        // Check for single amount with modifiers
        const singleValueRegex = /\$?(\d+(?:[,.]\d+)?)/;
        const singleMatch = lowercaseMessage.match(singleValueRegex);

        if (singleMatch) {
          const value = parseFloat(singleMatch[1].replace(/,/g, ''));

          // Check for "under", "less than", "at most", etc.
          if (lowercaseMessage.includes('under') ||
                  lowercaseMessage.includes('less than') ||
                  lowercaseMessage.includes('at most') ||
                  lowercaseMessage.includes('no more than') ||
                  lowercaseMessage.includes('maximum') ||
                  lowercaseMessage.includes('below')) {
            return { max: value };
          }

          // Check for "over", "more than", "at least", etc.
          if (lowercaseMessage.includes('over') ||
                  lowercaseMessage.includes('more than') ||
                  lowercaseMessage.includes('at least') ||
                  lowercaseMessage.includes('minimum') ||
                  lowercaseMessage.includes('above')) {
            return { min: value };
          }

          // Default to max if just a single number
          return { max: value };
        }

        // Check for common price bands expressed in words
        if (lowercaseMessage.includes('cheap') ||
                lowercaseMessage.includes('budget') ||
                lowercaseMessage.includes('inexpensive') ||
                lowercaseMessage.includes('affordable')) {

          if (lowercaseMessage.includes('laptop')) {
            return { max: 600 };
          } else if (lowercaseMessage.includes('smartphone') || lowercaseMessage.includes('phone')) {
            return { max: 300 };
          } else if (lowercaseMessage.includes('headphone')) {
            return { max: 100 };
          } else {
            return { max: 300 }; // Default affordable max
          }
        }

        if (lowercaseMessage.includes('mid-range') ||
                lowercaseMessage.includes('mid range') ||
                lowercaseMessage.includes('reasonable')) {

          if (lowercaseMessage.includes('laptop')) {
            return { min: 600, max: 1200 };
          } else if (lowercaseMessage.includes('smartphone') || lowercaseMessage.includes('phone')) {
            return { min: 300, max: 700 };
          } else if (lowercaseMessage.includes('headphone')) {
            return { min: 100, max: 200 };
          } else {
            return { min: 300, max: 700 }; // Default mid-range
          }
        }

        if (lowercaseMessage.includes('premium') ||
                lowercaseMessage.includes('high-end') ||
                lowercaseMessage.includes('high end') ||
                lowercaseMessage.includes('top tier') ||
                lowercaseMessage.includes('luxury')) {

          if (lowercaseMessage.includes('laptop')) {
            return { min: 1200 };
          } else if (lowercaseMessage.includes('smartphone') || lowercaseMessage.includes('phone')) {
            return { min: 700 };
          } else if (lowercaseMessage.includes('headphone')) {
            return { min: 200 };
          } else {
            return { min: 700 }; // Default premium min
          }
        }

        return null;
      };

      // Feature extraction function
      const extractFeatures = (message) => {
        const lowercaseMessage = message.toLowerCase();
        const features = [];

        // Common feature keywords by category
        const laptopFeatures = [
          { keyword: 'battery', value: 'long battery life' },
          { keyword: 'thin', value: 'thin and lightweight' },
          { keyword: 'lightweight', value: 'thin and lightweight' },
          { keyword: 'portab', value: 'portable' },
          { keyword: 'gaming', value: 'gaming performance' },
          { keyword: 'performance', value: 'high performance' },
          { keyword: 'fast', value: 'high performance' },
          { keyword: 'storage', value: 'large storage' },
          { keyword: 'ram', value: 'high RAM' },
          { keyword: 'display', value: 'high-quality display' },
          { keyword: 'screen', value: 'high-quality display' },
          { keyword: 'resolution', value: 'high-resolution display' },
          { keyword: 'touch', value: 'touchscreen' },
          { keyword: '4k', value: '4K display' },
          { keyword: 'design', value: 'premium design' },
          { keyword: 'professional', value: 'professional use' },
          { keyword: 'student', value: 'student use' },
          { keyword: 'work', value: 'work use' },
          { keyword: 'video', value: 'video editing' },
          { keyword: 'photo', value: 'photo editing' },
          { keyword: 'edit', value: 'content creation' }
        ];

        const smartphoneFeatures = [
          { keyword: 'battery', value: 'long battery life' },
          { keyword: 'camera', value: 'high-quality camera' },
          { keyword: 'photo', value: 'photography capabilities' },
          { keyword: 'storage', value: 'large storage' },
          { keyword: 'fast', value: 'fast performance' },
          { keyword: 'speed', value: 'fast performance' },
          { keyword: 'screen', value: 'high-quality display' },
          { keyword: 'display', value: 'high-quality display' },
          { keyword: 'design', value: 'premium design' },
          { keyword: 'water', value: 'water resistance' },
          { keyword: 'resistant', value: 'durability' },
          { keyword: 'durable', value: 'durability' },
          { keyword: 'gaming', value: 'mobile gaming' },
          { keyword: 'wireless', value: 'wireless charging' },
          { keyword: 'charging', value: 'fast charging' },
          { keyword: '5g', value: '5G connectivity' }
        ];

        const headphoneFeatures = [
          { keyword: 'noise', value: 'noise cancellation' },
          { keyword: 'cancel', value: 'noise cancellation' },
          { keyword: 'wireless', value: 'wireless' },
          { keyword: 'bluetooth', value: 'wireless' },
          { keyword: 'battery', value: 'long battery life' },
          { keyword: 'bass', value: 'bass quality' },
          { keyword: 'comfort', value: 'comfort' },
          { keyword: 'sound', value: 'sound quality' },
          { keyword: 'microphone', value: 'call quality' },
          { keyword: 'mic', value: 'call quality' },
          { keyword: 'call', value: 'call quality' },
          { keyword: 'workout', value: 'exercise use' },
          { keyword: 'exercise', value: 'exercise use' },
          { keyword: 'water', value: 'water resistance' },
          { keyword: 'resistant', value: 'durability' },
          { keyword: 'durable', value: 'durability' }
        ];

        // Determine which feature set to use based on the message content
        let featureSet = [];
        if (lowercaseMessage.includes('laptop')) {
          featureSet = laptopFeatures;
        } else if (lowercaseMessage.includes('phone') || lowercaseMessage.includes('smartphone')) {
          featureSet = smartphoneFeatures;
        } else if (lowercaseMessage.includes('headphone') || lowercaseMessage.includes('earphone')) {
          featureSet = headphoneFeatures;
        } else {
          // Combine all features if category is unclear
          featureSet = [...laptopFeatures, ...smartphoneFeatures, ...headphoneFeatures];
        }

        // Check for each feature
        for (const feature of featureSet) {
          if (lowercaseMessage.includes(feature.keyword)) {
            // Don't add duplicates
            if (!features.includes(feature.value)) {
              features.push(feature.value);
            }
          }
        }

        return features;
      };

      // Update user preference profile based on their behavior
      const updateUserProfile = (context) => {
        // Add the current context to search history
        const newHistory = [...searchHistory, {
          timestamp: Date.now(),
          category: context.category,
          budget: context.budget,
          preferences: [...context.preferences]
        }];

        setSearchHistory(newHistory);

        // Update user preference profile based on patterns
        const newProfile = {...userPreferenceProfile};

        // Update price consciousness based on budget patterns
        if (context.budget) {
          let budgetValue = context.budget.max;
          if (context.budget.min) {
            budgetValue = (context.budget.min + context.budget.max) / 2;
          }

          // Determine price consciousness relative to category
          if (context.category === 'laptop' && budgetValue < 800) {
            newProfile.priceConsciousness = 'high';
          } else if (context.category === 'smartphone' && budgetValue < 400) {
            newProfile.priceConsciousness = 'high';
          } else if (context.category === 'headphones' && budgetValue < 100) {
            newProfile.priceConsciousness = 'high';
          } else if (context.category === 'laptop' && budgetValue > 1500) {
            newProfile.priceConsciousness = 'low';
          } else if (context.category === 'smartphone' && budgetValue > 800) {
            newProfile.priceConsciousness = 'low';
          } else if (context.category === 'headphones' && budgetValue > 250) {
            newProfile.priceConsciousness = 'low';
          }
        }

        // Extract valued features from preferences
        if (context.preferences && context.preferences.length > 0) {
          const preferencesText = context.preferences.join(' ').toLowerCase();

          // Check for common valued features
          const featureKeywords = [
            'battery', 'camera', 'performance', 'storage', 'display',
            'screen', 'design', 'lightweight', 'durability', 'sound',
            'noise cancellation', 'wireless', 'fast charging'
          ];

          featureKeywords.forEach(keyword => {
            if (preferencesText.includes(keyword) && !newProfile.valuedFeatures.includes(keyword)) {
              newProfile.valuedFeatures.push(keyword);
            }
          });
        }

        // Update last searched category
        newProfile.lastSearched = context.category;

        setUserPreferenceProfile(newProfile);
      };

      // Enhanced AI prompt generation that incorporates user profile
      const generatePersonalizedPrompt = (basePrompt, context, userProfile) => {
        // Start with the base prompt
        let enhancedPrompt = basePrompt;

        // Add personalization layer based on user profile
        if (userProfile.valuedFeatures.length > 0) {
          enhancedPrompt += `\n\nBased on the user's previous interactions, they seem to value these features: ${userProfile.valuedFeatures.join(', ')}.`;
        }

        if (userProfile.priceConsciousness === 'high') {
          enhancedPrompt += `\n\nThe user appears to be price-conscious, so emphasize value and affordability in your response.`;
        } else if (userProfile.priceConsciousness === 'low') {
          enhancedPrompt += `\n\nThe user appears to prioritize premium features over price, so emphasize quality and performance in your response.`;
        }

        // Add cross-category intelligence
        if (userProfile.lastSearched && userProfile.lastSearched !== context.category) {
          enhancedPrompt += `\n\nThe user previously searched for ${userProfile.lastSearched}s before looking at ${context.category}s. They might be looking for integration between these products.`;
        }

        // Add conversation style adaptation
        if (context.preferences.some(pref => pref.length < 10)) {
          enhancedPrompt += `\n\nThe user tends to give brief responses, so keep your response concise and to the point.`;
        } else if (context.preferences.some(pref => pref.length > 50)) {
          enhancedPrompt += `\n\nThe user provides detailed responses, so you can be more thorough in your explanations.`;
        }

        return enhancedPrompt;
      };

      // Improved OpenAI API function with better error handling
      const callOpenAI = async (prompt, context) => {
        console.log("Calling OpenAI API with prompt:", prompt);

        try {
          // Create a backup plan in case the API call fails
          const backupResponses = {
            laptop: "Great choice! Let's find you the perfect laptop. Could you tell me your budget range?",
            smartphone: "Smartphones are essential these days! What's your budget for this purchase?",
            headphones: "I'd be happy to help you find headphones. What's your budget range?",
            budget: `Thanks for sharing your budget. What features are most important to you in a ${context.category}?`,
            preferences: `I understand you're looking for a ${context.category} with those features. Let me find some options for you.`,
            feedback: "Thanks for your feedback! Is there anything specific you'd like to know about these recommendations?"
          };

          const requestBody = {
            model: 'gpt-3.5-turbo',
            messages: [
              {
                role: 'system',
                content: `You are a product recommendation assistant. You help users find the perfect tech product based on their needs.
                          The available product categories are: laptops, smartphones, and headphones.
                          Current conversation context: ${JSON.stringify(context)}`
              },
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.7,
            max_tokens: 150
          };

          console.log("Request payload:", requestBody);

          const response = await fetch(`${API_BASE_URL}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${OPENAI_API_KEY}`
            },
            body: JSON.stringify(requestBody)
          });

          console.log("API Response status:", response.status);

          // Handle non-OK responses
          if (!response.ok) {
            const errorText = await response.text();
            console.error("API Error:", errorText);

            // Try to parse error as JSON if possible
            let errorJson = {};
            try {
              errorJson = JSON.parse(errorText);
            } catch (e) {
              console.log("Error text is not valid JSON");
            }

            // Fall back to hardcoded responses based on context
            if (context.stage === 'initial' && context.category) {
              return backupResponses[context.category];
            } else if (context.stage === 'budget') {
              return backupResponses.budget;
            } else if (context.stage === 'preferences') {
              return backupResponses.preferences;
            } else if (context.stage === 'feedback') {
              return backupResponses.feedback;
            }

            // Default fallback
            throw new Error(`API call failed: ${response.status} - ${errorJson?.error?.message || 'Unknown error'}`);
          }

          const data = await response.json();
          console.log("API Response successful:", data);

          // Verify the response structure before returning
          if (data?.choices?.[0]?.message?.content) {
            return data.choices[0].message.content;
          }

          throw new Error("Invalid response structure from API");
        } catch (error) {
          console.error("Error calling OpenAI API:", error);

          // Use rules-based fallback responses instead of AI for this request
          if (prompt.includes("budget") || context.stage === 'budget') {
            return "What's your budget range for this purchase? This will help me find options that fit your needs.";
          } else if (prompt.includes("features") || context.stage === 'preferences') {
            return `What features or qualities are most important to you in a ${context.category || 'product'}? For example, battery life, performance, etc.`;
          } else if (context.stage === 'initial') {
            return "I'm looking forward to helping you find the perfect tech product. Are you interested in a laptop, smartphone, or headphones?";
          } else if (context.stage === 'feedback') {
            return "Thank you for your feedback! Is there anything specific you'd like to know about these recommendations?";
          }

          return "I'll help you find the perfect product based on your needs. To get started, what type of product are you looking for?";
        }
      };

      // Enhanced recommendation generation
      const generateRecommendations = (context) => {
        // Filter products based on category
        let filteredProducts = products.filter(p => p.category === context.category);

        // Filter by budget if available
        if (context.budget) {
          if (context.budget.min && context.budget.max) {
            filteredProducts = filteredProducts.filter(p =>
                    p.price >= context.budget.min && p.price <= context.budget.max
            );
          } else if (context.budget.max) {
            filteredProducts = filteredProducts.filter(p => p.price <= context.budget.max);
          }
        }

        // Get relevant keywords from current preferences
        const preferencesText = context.preferences.join(' ').toLowerCase();

        // Include past user preferences if we're in a new search
        let enhancedPreferencesText = preferencesText;
        if (userPreferenceProfile.valuedFeatures.length > 0) {
          enhancedPreferencesText += ' ' + userPreferenceProfile.valuedFeatures.join(' ');
        }

        // Dynamic scoring system
        filteredProducts = filteredProducts.map(product => {
          let score = 0;

          // Check explicit features
          product.features.forEach(feature => {
            const featureLower = feature.toLowerCase();
            // Higher weight for explicit preferences
            if (preferencesText.includes(featureLower)) {
              score += 2;
            }
            // Lower weight for implied preferences from past searches
            else if (enhancedPreferencesText.includes(featureLower)) {
              score += 0.5;
            }
          });

          // Check idealFor matches
          product.idealFor.forEach(idealFor => {
            if (preferencesText.includes(idealFor.toLowerCase())) {
              score += 1;
            }
          });
          // Adjust score based on price consciousness
          if (userPreferenceProfile.priceConsciousness === 'high') {
            // For price-conscious users, lower prices get bonus points
            score += (1 - (product.price / 2000)) * 2; // Simple scaling factor
          }

          return { ...product, score };
        }).sort((a, b) => {
          // Sort by score first, then by rating if scores are equal
          if (b.score !== a.score) {
            return b.score - a.score;
          }
          return b.rating - a.rating;
        });

        // Take top 3 recommendations
        return filteredProducts.slice(0, 3);
      };

      // Improved process message function with advanced NLP and context awareness
      const processMessage = async (userMessage) => {
        // Add user message to chat
        setMessages(prevMessages => [...prevMessages, { role: 'user', content: userMessage }]);

        // Show typing indicator
        setIsTyping(true);

        // Parse user input for intent
        const lowercaseMessage = userMessage.toLowerCase();
        console.log("Processing message:", lowercaseMessage);

        // CRITICAL FIX: Always detect category first, regardless of stage
        const detectedCategory = detectCategory(userMessage);
        console.log("Detected category:", detectedCategory);

        // Current context state for AI
        let newContext = { ...productContext };
        let useAI = false;
        let aiPrompt = "";
        let response = "";

        console.log("Current stage:", productContext.stage);

        // If a category is detected at ANY stage, prioritize this detection
        if (detectedCategory) {
          // If they explicitly mentioned a category, always assume they want to search for this
          // regardless of what stage we're currently in

          // Only reset if the category is different or we're in feedback stage
          if (detectedCategory !== productContext.category || productContext.stage === 'feedback') {
            newContext = {
              category: detectedCategory,
              budget: null,
              preferences: [],
              stage: 'budget'
            };

            // Reset asked questions for new search
            setAskedQuestions({budget: false, features: false});

            response = `Great! I'll help you find the perfect ${detectedCategory}. What's your budget range for this purchase?`;
            useAI = false;

            // Update context, add response, and exit early
            setProductContext(newContext);
            setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: response }]);
            setIsTyping(false);
            return;
          }
        }

        // STAGE 1: Initial intent detection
        if (productContext.stage === 'initial') {
          // We already checked for category above, so if we're here, no category was detected

          // Try to extract features even without category
          const extractedFeatures = extractFeatures(userMessage);
          if (extractedFeatures.length > 0) {
            // Store these for later use when category is determined
            newContext.preferences = [...productContext.preferences, ...extractedFeatures];
          }

          // Use AI to understand the request better
          useAI = true;
          aiPrompt = `The user said: "${userMessage}". They might be looking for a tech product. Try to determine what category of product they're looking for (laptop, smartphone, or headphones). If unclear, ask them to specify what type of tech product they need.`;
        }

        // STAGE 2: Budget detection
        else if (productContext.stage === 'budget') {
          // Extract budget
          const extractedBudget = extractBudget(userMessage);
          console.log("Extracted budget:", extractedBudget);

          if (extractedBudget) {
            // Set budget and move to preferences
            newContext.budget = extractedBudget;
            newContext.stage = 'preferences';

            // Extract any features mentioned along with budget
            const extractedFeatures = extractFeatures(userMessage);
            if (extractedFeatures.length > 0) {
              newContext.preferences = [...newContext.preferences, ...extractedFeatures];
            }

            // Use AI to ask about features
            useAI = true;
            aiPrompt = `The user has specified a budget of ${newContext.budget.min ? `$${newContext.budget.min} to $${newContext.budget.max}` : `up to $${newContext.budget.max}`} for a ${newContext.category}. Ask them about what features or qualities are important to them.`;

            response = `Thanks for sharing your budget. What features are most important to you in a ${newContext.category}?`;
          }
          // If no budget detected but we already asked once
          else if (askedQuestions.budget) {
            // Set a reasonable default budget based on category
            if (newContext.category === 'laptop') {
              newContext.budget = { min: 600, max: 1500 };
            } else if (newContext.category === 'smartphone') {
              newContext.budget = { min: 300, max: 800 };
            } else if (newContext.category === 'headphones') {
              newContext.budget = { min: 80, max: 250 };
            } else {
              newContext.budget = { max: 500 }; // Generic fallback
            }

            console.log(`Using default budget for ${newContext.category}: ${JSON.stringify(newContext.budget)}`);
            newContext.stage = 'preferences';

            useAI = true;
            aiPrompt = `The user didn't specify an exact budget for their ${newContext.category}. Ask them what features they're looking for.`;

            response = `I'll use a standard budget range for ${newContext.category}s. What specific features are you looking for?`;
          }
          else {
            // First time asking about budget
            setAskedQuestions(prev => ({...prev, budget: true}));

            useAI = true;
            aiPrompt = `The user is looking for a ${newContext.category}. Ask them for a specific budget range.`;

            response = `I need a specific budget range to help you find the right ${newContext.category}. Could you please give me an amount, like "$100-$200" or "up to $300"?`;
          }
        }

        // STAGE 3: Preferences collection
        else if (productContext.stage === 'preferences') {
          // Set asked flag
          setAskedQuestions(prev => ({...prev, features: true}));

          // Extract features from user message
          const extractedFeatures = extractFeatures(userMessage);
          if (extractedFeatures.length > 0) {
            console.log("Features extracted:", extractedFeatures);
            newContext.preferences = [...productContext.preferences, ...extractedFeatures];
          } else {
            // If no specific features detected, store the whole message
            newContext.preferences = [...productContext.preferences, userMessage];
          }

          newContext.stage = 'recommendation';

          // Use AI to understand preferences
          useAI = true;
          const basePrompt = `The user is looking for a ${newContext.category} with a budget of ${newContext.budget.min ? `$${newContext.budget.min}-$${newContext.budget.max}` : `up to $${newContext.budget.max}`}. They said: "${userMessage}" about their preferences. Extract key features they're looking for and tell them you'll find some recommendations.`;
          aiPrompt = generatePersonalizedPrompt(basePrompt, newContext, userPreferenceProfile);

          // Wait for AI response before generating recommendations
          response = await callOpenAI(aiPrompt, newContext);
          setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: response }]);

          console.log("Generating recommendations for context:", newContext);

          // Update user preference profile before generating recommendations
          updateUserProfile(newContext);

          // Generate and filter recommendations
          const recommendations = generateRecommendations(newContext);
          console.log("Generated recommendations:", recommendations);

          if (recommendations.length > 0) {
            // Create recommendations message
            setTimeout(() => {
              setMessages(prevMessages => [
                ...prevMessages,
                { role: 'assistant', content: 'Based on your preferences, here are my top recommendations:' },
                { role: 'assistant', content: '', recommendations }
              ]);

              // Reset context for new recommendations
              setProductContext({
                category: null,
                budget: null,
                preferences: [],
                stage: 'feedback'
              });
              // Also reset asked questions for new conversation
              setAskedQuestions({budget: false, features: false});
              setIsTyping(false);
            }, 1000); // Shorter delay for better UX

            return;
          } else {
            response = `I couldn't find any ${newContext.category} that match your criteria. Would you like to try with a different budget or category?`;
            newContext.stage = 'initial';
            // Reset asked questions for new search
            setAskedQuestions({budget: false, features: false});
            useAI = false;
          }
        }

        // STAGE 4: Handle feedback
        else if (productContext.stage === 'feedback') {
          // Category detection was already handled at the beginning
          // Here we handle other feedback cases

          // Check for request to start over
          if (lowercaseMessage.includes('new search') ||
                  lowercaseMessage.includes('start over') ||
                  lowercaseMessage.includes('different') ||
                  lowercaseMessage.includes('something else') ||
                  lowercaseMessage.includes('look for') ||
                  lowercaseMessage.includes('another') ||
                  lowercaseMessage === 'no' ||
                  lowercaseMessage === 'nope' ||
                  lowercaseMessage === 'not really' ||
                  lowercaseMessage === 'no thanks') {

            // Start a new search
            newContext = {
              category: null,
              budget: null,
              preferences: [],
              stage: 'initial'
            };

            // Reset asked questions for new search
            setAskedQuestions({budget: false, features: false});

            // Generic start over
            response = "I'd be happy to help you find something else! What type of product are you looking for?";
            useAI = false;
          } else {
            // This is a normal feedback question or comment
            useAI = true;
            aiPrompt = `The user said: "${userMessage}" after receiving product recommendations. Respond to their feedback or answer questions about the recommended products. If they ask for more specific information, suggest they could refine their search criteria.`;

            // Provide a fallback that DOESN'T repeat the same message
            response = "Thanks for your feedback. Is there anything else you'd like to know about today?";
          }
        }

        // Call OpenAI API if needed
        if (useAI && !response) {
          response = await callOpenAI(aiPrompt, newContext);
        }

        // Set new context and add assistant message
        setProductContext(newContext);
        setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: response }]);
        setIsTyping(false);
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        if (inputText.trim() === '') return;

        await processMessage(inputText);
        setInputText('');
      };

      // Handle demo buttons for predefined flows
      const runDemo = async (demoType) => {
        switch(demoType) {
          case 'laptop':
            await processMessage("I need a new laptop for work");
            setTimeout(async () => {
              await processMessage("My budget is around $1000-1500");
              setTimeout(async () => {
                await processMessage("I need something with good battery life and powerful enough for video editing");
              }, 1500);
            }, 1500);
            break;
          case 'phone':
            await processMessage("Looking for a new smartphone");
            setTimeout(async () => {
              await processMessage("I can spend up to $800");
              setTimeout(async () => {
                await processMessage("I really care about camera quality and battery life");
              }, 1500);
            }, 1500);
            break;
          case 'headphones':
            await processMessage("I want wireless headphones");
            setTimeout(async () => {
              await processMessage("Under $200 please");
              setTimeout(async () => {
                await processMessage("Noise cancellation would be nice for my commute");
              }, 1500);
            }, 1500);
            break;
        }
      };

      return (
              <div className="flex flex-col h-full max-w-6xl mx-auto bg-gray-50">
                <div className="flex flex-col h-full">
                  {/* Header */}
                  <div className="bg-blue-600 text-white p-4 shadow-md">
                    <h1 className="text-2xl font-bold">Product AI Assistant</h1>
                    <p className="text-sm opacity-90">Ask me about tech products and I'll help you find the perfect match using AI</p>
                  </div>

                  {/* Debug panel for development - comment out for production */}
                  <div className="bg-gray-800 text-xs text-gray-300 p-2">
                    <span>Category: {productContext.category || 'None'}</span>
                    <span className="ml-3">Budget: {productContext.budget ?
                            (productContext.budget.min ?
                                    `$${productContext.budget.min}-$${productContext.budget.max}` :
                                    `$${productContext.budget.max}`) :
                            'None'}
              </span>
                    <span className="ml-3">Stage: {productContext.stage}</span>
                    <span className="ml-3">Prefs: {productContext.preferences.length}</span>
                  </div>

                  {/* Demo buttons */}
                  <div className="bg-blue-100 p-3 flex space-x-2 overflow-x-auto">
                    <span className="text-sm text-blue-800 font-medium whitespace-nowrap my-auto">Try a demo:</span>
                    <button
                            onClick={() => runDemo('laptop')}
                            className="bg-white hover:bg-blue-50 text-blue-600 text-sm font-medium py-1 px-3 rounded-full shadow-sm"
                    >
                      Laptop search
                    </button>
                    <button
                            onClick={() => runDemo('phone')}
                            className="bg-white hover:bg-blue-50 text-blue-600 text-sm font-medium py-1 px-3 rounded-full shadow-sm"
                    >
                      Smartphone search
                    </button>
                    <button
                            onClick={() => runDemo('headphones')}
                            className="bg-white hover:bg-blue-50 text-blue-600 text-sm font-medium py-1 px-3 rounded-full shadow-sm"
                    >
                      Headphones search
                    </button>
                  </div>

                  {/* Messages container */}
                  <div className="flex-1 overflow-y-auto p-4 bg-white">
                    {messages.map((message, index) => (
                            <div key={index} className={`mb-4 ${message.role === 'user' ? 'text-right' : ''}`}>
                              {/* Regular message */}
                              {!message.recommendations && (
                                      <div className={`inline-block p-3 rounded-lg max-w-3xl ${
                                              message.role === 'user'
                                                      ? 'bg-blue-500 text-white rounded-br-none'
                                                      : 'bg-gray-100 text-gray-800 rounded-bl-none'
                                      }`}>
                                        {message.content}
                                      </div>
                              )}

                              {/* Recommendations display */}
                              {message.recommendations && (
                                      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mt-2">
                                        {message.recommendations.map((product) => (
                                                <div key={product.id} className="bg-white rounded-lg border border-gray-200 shadow-sm overflow-hidden">
                                                  <img
                                                          src={product.image}
                                                          alt={product.name}
                                                          className="w-full h-40 object-cover"
                                                  />
                                                  <div className="p-4">
                                                    <div className="flex justify-between items-start mb-2">
                                                      <h3 className="font-bold text-lg">{product.name}</h3>
                                                      <span className="font-bold text-blue-600">${product.price}</span>
                                                    </div>
                                                    <div className="flex items-center mb-2">
                                                      <div className="flex text-yellow-400">
                                                        {'★'.repeat(Math.floor(product.rating))}
                                                        {'☆'.repeat(5 - Math.floor(product.rating))}
                                                      </div>
                                                      <span className="text-sm text-gray-600 ml-1">{product.rating}</span>
                                                    </div>
                                                    <ul className="text-sm text-gray-600 mb-3">
                                                      {product.features.slice(0, 3).map((feature, idx) => (
                                                              <li key={idx} className="flex items-start mb-1">
                                                                <span className="text-green-500 mr-1">✓</span>
                                                                {feature}
                                                              </li>
                                                      ))}
                                                    </ul>
                                                    <p className="text-xs text-gray-500 mt-1">
                                                      Ideal for: {product.idealFor.join(', ')}
                                                    </p>
                                                  </div>
                                                </div>
                                        ))}
                                      </div>
                              )}
                            </div>
                    ))}

                    {/* Typing indicator */}
                    {isTyping && (
                            <div className="flex items-center space-x-2 mb-4">
                              <div className="bg-gray-100 p-3 rounded-lg text-gray-500">
                                <div className="flex space-x-1">
                                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></div>
                                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-pulse delay-75"></div>
                                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-pulse delay-150"></div>
                                </div>
                              </div>
                            </div>
                    )}

                    <div ref={messagesEndRef} />
                  </div>

                  {/* Input form */}
                  <form onSubmit={handleSubmit} className="p-4 border-t border-gray-200 bg-white">
                    <div className="flex">
                      <input
                              type="text"
                              value={inputText}
                              onChange={(e) => setInputText(e.target.value)}
                              className="flex-1 border border-gray-300 rounded-l-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder="Ask about products..."
                              disabled={isTyping}
                      />
                      <button
                              type="submit"
                              className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-r-lg disabled:bg-blue-300"
                              disabled={isTyping || inputText.trim() === ''}
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                          <path fillRule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clipRule="evenodd" />
                        </svg>
                      </button>
                    </div>
                  </form>
                </div>
              </div>
      );
    };
  })();

  // Set up App component
  const App = () => {
    return (
            <div className="App h-full">
              <ProductRecommender />
            </div>
    );
  };

  // Render the App to the DOM
  ReactDOM.render(<App />, document.getElementById('root'));
</script>
</body>
</html>